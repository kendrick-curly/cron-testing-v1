name: Google Chat Alerts

on:
  workflow_dispatch:
  push:

jobs:
  check-testing-branch:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout testing branch
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0   # needed for tag and history checks
          lfs: true


      # - name: Check if commit has a tag
      #   id: tagcheck
      #   run: |
      #     if git describe --tags --exact-match >/dev/null 2>&1; then
      #       TAG=$(git describe --tags --exact-match)
      #       echo "Found tag: $TAG ${{github.ref_name}}"
      #     else
      #       echo "::error::âŒ ${{github.ref_name}} This commit has NO TAG. Builds require a tag when using versioning: Tag."
      #       exit 1
      #     fi
       
      # - name: testing
      #   id: sasd
      #   run: echo "test"

      - name: Get PR descriptions between latest and second latest tagged commit
        id: get-pr-descriptions
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get all tags sorted by version (most recent first)
          # --sort=-v:refname sorts tags in descending order by version
          echo "Fetching tags..." >&2
          TAGS=$(git tag --sort=-creatordate)

          # Get the latest tag (first line)
          LATEST_TAG=$(echo "$TAGS" | head -n 1)

          # Get the second latest tag (second line)
          SECOND_LATEST_TAG=$(echo "$TAGS" | head -n 2 | tail -n 1)

          echo "Latest tag: $LATEST_TAG" >&2
          echo "Second latest tag: $SECOND_LATEST_TAG" >&2

          # Check if we found both tags
          if [ -z "$LATEST_TAG" ] || [ -z "$SECOND_LATEST_TAG" ]; then
            echo "::error::Not enough tags found. Need at least 2 tags."
            exit 1
          fi

          # Get the commit hash that the latest tag points to
          LATEST_COMMIT=$(git rev-list -n 1 "$LATEST_TAG")
          echo "Latest tagged commit: $LATEST_COMMIT" >&2

          # Get the commit hash that the second latest tag points to
          SECOND_LATEST_COMMIT=$(git rev-list -n 1 "$SECOND_LATEST_TAG")
          echo "Second latest tagged commit: $SECOND_LATEST_COMMIT" >&2

          # Get all commits between second latest tagged commit and latest tagged commit
          # The range SECOND_LATEST_COMMIT..LATEST_COMMIT means:
          # "all commits reachable from LATEST_COMMIT but not from SECOND_LATEST_COMMIT"
          echo "Fetching commits between $SECOND_LATEST_TAG and $LATEST_TAG..." >&2
          COMMITS=$(git rev-list $SECOND_LATEST_COMMIT..$LATEST_COMMIT)

          # Count how many commits we found
          COMMIT_COUNT=$(echo "$COMMITS" | wc -l)
          echo "Found $COMMIT_COUNT commit(s) between the two tags" >&2

          # Extract repository owner and name from GITHUB_REPOSITORY
          # Example: if GITHUB_REPOSITORY is "octocat/Hello-World"
          # REPO_OWNER will be "octocat" and REPO_NAME will be "Hello-World"
          REPO_OWNER=$(echo ${{ github.repository }} | cut -d'/' -f1)
          REPO_NAME=$(echo ${{ github.repository }} | cut -d'/' -f2)
          echo "Repository: $REPO_OWNER/$REPO_NAME" >&2
          echo "" >&2

          # Initialize associative array to track unique PRs by PR number
          declare -A UNIQUE_PRS

          # Initialize variable to collect all PR descriptions
          ALL_PR_DESCRIPTIONS=""

          # Loop through each commit and find associated merged PRs
          echo "=== Collecting PR Descriptions ===" >&2
          for commit in $COMMITS; do
            # Show which commit we're currently checking (to stderr for debugging)
            echo "Checking commit: $commit" >&2

            # Use GitHub API to get PRs associated with this specific commit
            # Extract PR number and description as JSON objects
            PR_DATA=$(gh api "/repos/$REPO_OWNER/$REPO_NAME/commits/$commit/pulls" \
              --jq '.[] | select(.merged_at != null) | {number: .number, body: (.body // "No description provided")}')

            # Process each PR found for this commit
            if [ -n "$PR_DATA" ]; then
              while IFS= read -r pr_json; do
                # Extract PR number and description
                PR_NUMBER=$(echo "$pr_json" | jq -r '.number')
                PR_DESCRIPTION=$(echo "$pr_json" | jq -r '.body')

                # Check if we've already seen this PR number
                if [ -z "${UNIQUE_PRS[$PR_NUMBER]}" ]; then
                  # Check if PR description contains <gc> markers
                  if [[ "$PR_DESCRIPTION" =~ \<gc\>(.*)\</gc\> ]]; then
                    # Extract content between <gc> and </gc> markers
                    GC_CONTENT="${BASH_REMATCH[1]}"

                    # Mark this PR number as seen
                    UNIQUE_PRS[$PR_NUMBER]=1

                    # Add the extracted content to our collection
                    if [ -n "$ALL_PR_DESCRIPTIONS" ]; then
                      ALL_PR_DESCRIPTIONS="$ALL_PR_DESCRIPTIONS\n---\n$GC_CONTENT"
                    else
                      ALL_PR_DESCRIPTIONS="$GC_CONTENT"
                    fi
                    echo "Found unique PR #$PR_NUMBER with <gc> markers for commit $commit" >&2
                  else
                    echo "Skipping PR #$PR_NUMBER - no <gc> markers found" >&2
                  fi
                else
                  echo "Skipping duplicate PR #$PR_NUMBER for commit $commit" >&2
                fi
              done <<< "$PR_DATA"
            else
              echo "No merged PR found for commit $commit" >&2
            fi
          done

          echo "" >&2
          echo "=== Final Output (PR Descriptions Only) ===" >&2

          # Convert Markdown links [text](url) to "text: url" format for Google Chat
          # Google Chat auto-detects plain URLs and makes them clickable
          ALL_PR_DESCRIPTIONS_FORMATTED=$(echo -e "$ALL_PR_DESCRIPTIONS" | sed -E 's/\[([^]]+)\]\(([^)]+)\)/\1: \2/g')

          # Cache the output for use in subsequent steps
          # Use GITHUB_OUTPUT to set the step output
          {
            echo "pr_descriptions<<EOF"
            echo -e "$ALL_PR_DESCRIPTIONS_FORMATTED"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          # Create JSON-escaped version for use in JSON structures
          # Use jq to properly escape the text for JSON
          PR_DESCRIPTIONS_ESCAPED=$(echo -e "$ALL_PR_DESCRIPTIONS_FORMATTED" | jq -Rs .)
          echo "pr_descriptions_json=$PR_DESCRIPTIONS_ESCAPED" >> $GITHUB_OUTPUT

      # ----------------------------------------------------------
      # GOOGLE CHAT NOTIFICATION
      # ----------------------------------------------------------
      - name: Notify Google Chat
        uses: SimonScholz/google-chat-action@main
        with:
          webhookUrl: 'https://chat.googleapis.com/v1/spaces/AAQAhiGyDYM/messages?key=AIzaSyDdI0hCZtE6vySjMm-WEfRq3CPzqKqqsHI&token=M7-te_T--hRJDrC-JtgDu_HxG_ivXvG-_cVbYuR5zz8'
          jobStatus: ${{ job.status }}
          threadKey: ${{ github.event.number }}
          title: "APK"
          subtitle: "META Release Channel"
          additionalSections: '[{"header": "Release Notes", "widgets": [{"textParagraph": {"text": ${{ steps.get-pr-descriptions.outputs.pr_descriptions_json }}}}]}]'
